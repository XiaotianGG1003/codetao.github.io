import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as r,a as c,b as o,f as t}from"./app-f91ee567.js";const l="/assets/image-20240331134000807-cbacea3b.png",d="/assets/image-20240331140453252-85cf0511.png",i={},h=o("p",null,"JVM虚拟机入门",-1),n=t('<h2 id="threadlocal底层原理分析" tabindex="-1"><a class="header-anchor" href="#threadlocal底层原理分析" aria-hidden="true">#</a> ThreadLocal底层原理分析</h2><h3 id="什么是threadlocal" tabindex="-1"><a class="header-anchor" href="#什么是threadlocal" aria-hidden="true">#</a> 什么是ThreadLocal?</h3><p>ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，是每个线程独有的变量，每个线程只能访问自己内部的 ThreadLocal 对象。是线程安全的。</p><h3 id="threadlocal实现" tabindex="-1"><a class="header-anchor" href="#threadlocal实现" aria-hidden="true">#</a> ThreadLocal实现</h3><p>每个线程上都有一个ThreadLocalMap对象。ThreadLocal就是操作当前线程的ThreadLocalMap的工具类。</p><figure><img src="'+l+'" alt="image-20240331134000807" tabindex="0" loading="lazy"><figcaption>image-20240331134000807</figcaption></figure><p>当每次调ThreadLocal的set方法就是往ThreadLocalMap里放入Entry对象，ThreadLocalMap内部是通过数组实现的哈希表，Key为ThreadLocal对象, value为object缓存对象，每个Entry数组对象继承自弱引用，关联ThreadLocal对象，如果ThreadLocal对象不再使用，可以被GC回收掉。</p><p>但Entry对象的value值是通过线程强引用的，Entry的value值无法被回收，如果value值存入太大，可能会导致内存泄漏。</p><p>**解决方法：**调用ThreadLocal的remove方法清除Entry对象。</p><figure><img src="'+d+'" alt="image-20240331140453252" tabindex="0" loading="lazy"><figcaption>image-20240331140453252</figcaption></figure>',10);function s(p,m){return e(),r("div",null,[h,c(" more "),n])}const _=a(i,[["render",s],["__file","jvm.html.vue"]]);export{_ as default};
